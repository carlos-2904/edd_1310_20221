class Nodo:
    def __init__( self , value , siguiente= None):
        self.data = value       # falta encapsulamiento
        self.siguiente = siguiente

class LinkedList:
    def __init__( self ): # haskjdhasjkdhasjh aksjdh
        self.__head = None

    def is_empty( self ):
        return self.__head == None

    def append( self , value ):
        nuevo = Nodo( value )
        if self.__head == None: # self.is_empty()
            self.__head = nuevo
        else:
            curr_node = self.__head
            while curr_node.siguiente != None:
                curr_node = curr_node.siguiente
            curr_node.siguiente = nuevo

    def transversal( self ):
        curr_node = self.__head
        while curr_node != None:
            print(f" { curr_node.data } -> " , end="")
            curr_node = curr_node.siguiente
        print(" ")

    def remove( self , value ):
        curr_node = self.__head
        while curr_node.data != value and curr_node.siguiente != None:
            curr_node= curr_node.siguiente
        if curr_node.data == value:



def tail(self):#Regresa el ultimo nodo.
        curr_node=self.__head
        while curr_node != None:
            curr_new= curr_node
            curr_node= curr_node.siguiente
        print(curr_new.data)

ass NodoDoble:
    def __init__( self , value , siguiente = None , anterior = None )
        self.data = value
        self.siguiente = siguiente
        self.anterior = anterior

class DoubleLinkedList:
    def __init__( self ):
        self.__head = NodoDoble( none)
        self.__tail = NodoDoble( none)
        sefl.__size = 0
    def get_size( self ):
        return self.__size == 0
    def is_empty( self ):
        return self.__size == 0
    def append(self , value ):
        if self.is_empty() :
            nuevo = NodoDoble( value )
            self.__head = nuevo
            self.__tail = nuevo
        else:
            nuevo = NodoDoble 
